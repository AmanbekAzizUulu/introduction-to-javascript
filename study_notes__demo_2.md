# Study notes
---

В JavaScript, **функции** и **методы** являются похожими понятиями, но между ними есть важное различие, которое связано с их контекстом использования.

### 1. **Функции (Functions)**

**Функция** — это блок кода, который выполняет определённую задачу и может быть вызван в любой момент программы. Функция в JavaScript может быть определена с использованием ключевого слова `function` или с помощью выражений, например, стрелочных функций.

#### Пример обычной функции:

```javascript
function greet(name) {
    console.log("Hello, " + name);
}

greet("Alice"); // "Hello, Alice"
```

Функции могут быть:

- **Глобальными** (доступными во всей программе).
- **Локальными** (например, внутри другой функции).

### 2. **Методы (Methods)**

**Метод** — это функция, которая является **свойством объекта**. Другими словами, метод — это функция, привязанная к определённому объекту. Когда мы вызываем метод, это всегда происходит через объект, к которому этот метод принадлежит.

#### Пример метода:

```javascript
let person = {
    name: "Alice",
    greet: function() {
        console.log("Hello, " + this.name);
    }
};

person.greet(); // "Hello, Alice"
```

Здесь:

- `greet` — это метод объекта `person`.
- Мы вызываем метод через объект: `person.greet()`.

### Ключевые различия:

1. **Контекст (this)**

    - В **функции** значение `this` будет зависеть от того, как она вызывается. В глобальном контексте `this` обычно указывает на глобальный объект (в браузере это `window`).
    - В **методе** `this` указывает на объект, к которому этот метод привязан. В примере выше, `this.name` ссылается на `name` объекта `person`.
2. **Привязка к объекту**

    - **Функции** могут быть независимыми и не привязаны к объектам.
    - **Методы** всегда являются свойствами объектов и вызываются через эти объекты.
3. **Использование**

    - **Функции** могут использоваться для выполнения различных операций, включая обработку данных, вычисления и т. д.
    - **Методы** используются для взаимодействия с данными объекта или выполнения операций, которые относятся к состоянию объекта.

#### Пример:

```javascript
// Функция
function add(a, b) {
    return a + b;
}

console.log(add(3, 5)); // 8

// Метод
let calculator = {
    add: function(a, b) {
        return a + b;
    }
};

console.log(calculator.add(3, 5)); // 8
```

В данном примере `add` как функция не привязана к объекту, а как метод `add` является частью объекта `calculator`.

---

Функции в JavaScript действительно могут быть похожи на лямбда-выражения в других языках программирования, но есть важные различия. Давайте разберемся, что такое **функции** и **лямбда-выражения** в JavaScript.

### 1. **Функции в JavaScript**

Функции — это основные блоки кода в JavaScript, которые могут быть определены с использованием ключевого слова `function` или с помощью **стрелочных функций** (которые часто называют лямбда-выражениями в других языках).

#### Пример обычной функции:

```javascript
function greet(name) {
    return "Hello, " + name;
}

console.log(greet("Alice")); // "Hello, Alice"
```

#### Пример стрелочной функции (лямбда-выражение):

```javascript
const greet = (name) => {
    return "Hello, " + name;
};

console.log(greet("Bob")); // "Hello, Bob"
```

### 2. **Лямбда-выражения в других языках**

Лямбда-выражение — это анонимная функция, которая, как правило, используется для краткой записи функций, особенно когда они передаются в качестве аргументов.

#### Пример лямбда-выражения в Python:

```python
greet = lambda name: "Hello, " + name
print(greet("Charlie"))  # "Hello, Charlie"
```

### 3. **Стрелочные функции как лямбда-выражения**

В JavaScript **стрелочные функции** (`=>`) являются короткой и более лаконичной формой записи анонимных функций, что делает их похожими на лямбда-выражения в других языках.

#### Пример:

```javascript
const add = (a, b) => a + b;
console.log(add(2, 3)); // 5
```

### Ключевые отличия:

- **Стрелочные функции** в JavaScript — это именно **синтаксический сахар** для краткой записи анонимных функций. Они не обязательно являются "лямбда-выражениями" в строгом смысле этого термина, но выполняют схожую роль.
- Основное отличие стрелочных функций в JavaScript от обычных функций заключается в том, как они обрабатывают контекст `this`:
    - **Стрелочные функции** не имеют своего собственного `this`. Они наследуют значение `this` из окружающего контекста (лексическое связывание `this`).
    - **Обычные функции** имеют свой собственный `this`, который зависит от того, как эта функция была вызвана.

### Пример разницы в поведении `this`:

```javascript
const obj = {
    name: "Alice",
    greet: function() {
        setTimeout(function() {
            console.log("Hello, " + this.name); // 'this' будет указывать на глобальный объект (window в браузере)
        }, 1000);
    }
};

obj.greet(); // undefined, так как 'this' в обычной функции будет указывать на глобальный объект
```

```javascript
const obj = {
    name: "Alice",
    greet: function() {
        setTimeout(() => {
            console.log("Hello, " + this.name); // 'this' будет указывать на obj
        }, 1000);
    }
};

obj.greet(); // "Hello, Alice"
```

### Вывод:

- Стрелочные функции (лямбда-выражения) — это просто более короткая и удобная форма записи функций.
- В отличие от обычных функций, стрелочные функции наследуют значение `this` из окружающего контекста, что делает их особенно полезными в ситуациях, где нужно сохранить контекст вызова.

Таким образом, **стрелочные функции** в JavaScript выполняют роль **лямбда-выражений**, но важно помнить о различиях в поведении `this` между обычными функциями и стрелочными.

---

Создание возможности присваивать функцию переменной в JavaScript позволяет достичь гибкости и динамичности в коде. Это одна из особенностей функционального программирования, где функции могут быть переданы как значения. Вот несколько причин, почему это полезно:

### 1. **Функции как объекты первого класса**:
В JavaScript функции являются **объектами первого класса**, что означает, что они могут быть:
   - Присваиваемыми переменным.
   - Передаваемыми в качестве аргументов другим функциям.
   - Возвращаемыми из других функций.

Этот подход позволяет создавать более динамичные и адаптируемые программы.

### Пример:
```javascript
let greet = function(name) {
  return `Hello, ${name}!`;
};

console.log(greet('Alice'));  // "Hello, Alice!"
```

### 2. **Использование функций как параметров**:
Функции, присвоенные переменным, могут быть переданы в другие функции в качестве аргументов, что позволяет создавать высокоабстрактные и повторно используемые компоненты.

Пример с функцией обратного вызова:
```javascript
function executeOperation(a, b, operation) {
  return operation(a, b);
}

let add = (a, b) => a + b;
let subtract = (a, b) => a - b;

console.log(executeOperation(5, 3, add));      // 8
console.log(executeOperation(5, 3, subtract)); // 2
```

### 3. **Замыкания (Closures)**:
Когда функция присваивается переменной, она может захватывать и запоминать внешние переменные (замыкания). Это позволяет создавать более сложные и мощные структуры, такие как фабрики функций.

Пример:
```javascript
function multiplier(factor) {
  return function(number) {
    return number * factor;
  };
}

let double = multiplier(2);
let triple = multiplier(3);

console.log(double(4)); // 8
console.log(triple(4)); // 12
```

### 4. **Инкапсуляция логики**:
Использование функций как значений помогает инкапсулировать поведение, делая код более модульным и читаемым. Это позволяет скрыть сложную логику внутри функции, которая может быть вызвана при необходимости.

Пример:
```javascript
let calculateTax = function(price) {
  const TAX_RATE = 0.15;
  return price * TAX_RATE;
};

console.log(calculateTax(100)); // 15
```

### 5. **Высокая гибкость при передаче функций в качестве аргументов**:
Функции, передаваемые в качестве параметров, позволяют создавать гибкие структуры программ, которые можно конфигурировать в зависимости от потребностей, без необходимости переписывать основной код.

Пример:
```javascript
function filterArray(arr, filterFunc) {
  return arr.filter(filterFunc);
}

let isEven = (num) => num % 2 === 0;
let isOdd = (num) => num % 2 !== 0;

console.log(filterArray([1, 2, 3, 4, 5], isEven)); // [2, 4]
console.log(filterArray([1, 2, 3, 4, 5], isOdd));  // [1, 3, 5]
```

### 6. **Функции как события или обработчики**:
В JavaScript функции часто используются как обработчики событий, передаваясь в качестве аргументов в функции или методы (например, обработчики событий в DOM).

Пример:
```javascript
button.addEventListener('click', function() {
  alert('Button clicked!');
});
```

### 7. **Функции для динамического выполнения кода**:
Функции могут быть определены на лету, что позволяет создавать динамичные и адаптируемые программы. Это важно, когда вам нужно выполнить операции, определяемые на основе данных или условий.

Пример:
```javascript
let operation = prompt('Enter operation: add, subtract, multiply');

let execute;
if (operation === 'add') {
  execute = (a, b) => a + b;
} else if (operation === 'subtract') {
  execute = (a, b) => a - b;
}

console.log(execute(5, 3)); // В зависимости от ввода выводит результат сложения или вычитания
```

### Заключение:
Присваивание функции переменной расширяет возможности программирования, обеспечивая гибкость в работе с кодом. Оно позволяет создавать более динамичные, абстрактные и функционально мощные программы, которые могут адаптироваться к изменениям, эффективно управлять состоянием и обеспечивать высокий уровень повторного использования кода.


---

Этот код определяет метод `dist` для объекта `points`. Метод вычисляет расстояние между двумя точками, которые предполагается хранить в объекте `points`. Рассмотрим его по частям:

### 1. **Определение метода `dist`**:
```javascript
points.dist = function() { ... };
```
Здесь мы добавляем метод `dist` к объекту `points`. В этом методе используется ключевое слово `this`, которое ссылается на объект, в котором был вызван метод. Предположительно, `points` — это массив, содержащий два объекта, представляющих точки, с координатами `x` и `y`.

### 2. **Извлечение точек**:
```javascript
let point_1 = this[0];
let point_2 = this[1];
```
Здесь мы присваиваем переменные `point_1` и `point_2` значения из массива `this`, предполагая, что он содержит как минимум два элемента. `point_1` будет равен первому элементу массива, а `point_2` — второму.

### 3. **Вычисление разности координат**:
```javascript
let a = point_2.x - point_1.x;
let b = point_2.y - point_1.y;
```
Здесь мы рассчитываем разницу между координатами точек по оси `x` и по оси `y`:
- `a` — это разница по оси `x` (горизонтальное расстояние между точками).
- `b` — это разница по оси `y` (вертикальное расстояние между точками).

### 4. **Вычисление расстояния**:
```javascript
return Math.sqrt(a * a + b * b);
```
Здесь мы используем теорему Пифагора для вычисления расстояния между двумя точками в двумерном пространстве. Теорема Пифагора утверждает, что расстояние между двумя точками (или длина гипотенузы) равно квадратному корню из суммы квадратов разности по осям `x` и `y`:
- \( \text{distance} = \sqrt{(a^2 + b^2)} \)
- Где \( a = \text{разность по x} \) и \( b = \text{разность по y} \).

Метод `Math.sqrt` вычисляет квадратный корень из выражения \( a^2 + b^2 \), давая искомое расстояние.

### Пример:
Предположим, что `points` выглядит так:
```javascript
let points = [
  { x: 1, y: 2 },  // точка 1
  { x: 4, y: 6 }   // точка 2
];
```
Тогда, вызвав метод `dist`:
```javascript
let distance = points.dist();
```
1. `point_1` будет `{ x: 1, y: 2 }`, а `point_2` будет `{ x: 4, y: 6 }`.
2. Разница по оси `x`: `a = 4 - 1 = 3`.
3. Разница по оси `y`: `b = 6 - 2 = 4`.
4. Расстояние: \( \sqrt{3^2 + 4^2} = \sqrt{9 + 16} = \sqrt{25} = 5 \).

Таким образом, результат будет `5`.

### Итог:
Этот метод рассчитывает и возвращает расстояние между двумя точками в двумерном пространстве с использованием теоремы Пифагора.

---

Да, правильно! В данном примере, `point_1` и `point_2` — это два объекта, представляющие точки в двумерном пространстве. Каждый из них имеет свойства `x` и `y`, которые представляют координаты точки на плоскости.

В примере, который вы привели, объект `points` является массивом, состоящим из двух объектов, где каждый объект имеет свои координаты `x` и `y`.

Пример структуры `points`:
```javascript
let points = [
  { x: 1, y: 2 },  // point_1
  { x: 4, y: 6 }   // point_2
];
```
Здесь:
- `point_1` — это объект `{ x: 1, y: 2 }`, который является первым элементом массива `points`.
- `point_2` — это объект `{ x: 4, y: 6 }`, который является вторым элементом массива `points`.

Когда в методе `dist` вы пишете:
```javascript
let point_1 = this[0];
let point_2 = this[1];
```
Это означает, что переменные `point_1` и `point_2` будут ссылаться на первый и второй объекты в массиве `points`, соответственно.

### Итог:
Да, `point_1` и `point_2` — это объекты, представляющие точки, и их можно считать объектами типа "точка" с координатами `x` и `y`.

---

Да, в этом контексте `this[0]` и `this[1]` в функции означают то же самое, что и `points[0]` и `points[1]`, если функция `dist` будет вызвана как метод объекта `points`.

В JavaScript, когда функция вызывается как метод объекта, ключевое слово `this` внутри этой функции ссылается на сам объект, на который этот метод был вызван. Таким образом, если вы добавляете метод `dist` в массив `points`, то в контексте этого метода `this` будет указывать на массив `points`.

Пример:
```javascript
let points = [
  { x: 1, y: 2 },
  { x: 4, y: 6 }
];

points.dist = function() {
  let point_1 = this[0];  // this ссылается на массив points
  let point_2 = this[1];  // this ссылается на массив points

  let a = point_2.x - point_1.x;
  let b = point_2.y - point_1.y;

  return Math.sqrt(a * a + b * b);
};

console.log(points.dist());  // Вызов метода dist на массиве points
```

Здесь, `this` в методе `dist` указывает на сам массив `points`. Поэтому `this[0]` и `this[1]` — это те же самые объекты, что и `points[0]` и `points[1]`.

### Итог:
`this[0]` и `this[1]` внутри метода объекта `points` будут эквивалентны `points[0]` и `points[1]`, так как `this` ссылается на сам объект, а в данном случае — на массив `points`.

---

Да, метод `dist` можно вызвать на другом объекте, но важно, чтобы структура этого объекта соответствовала тому, что ожидает метод. В случае, если вы хотите вызвать метод `dist` на другом объекте, который имеет схожую структуру (например, массив с объектами, имеющими свойства `x` и `y`), то такой вызов будет работать.

Пример:
```javascript
let points1 = [
  { x: 1, y: 2 },
  { x: 4, y: 6 }
];

let points2 = [
  { x: 3, y: 5 },
  { x: 8, y: 9 }
];

points1.dist = function() {
  let point_1 = this[0];
  let point_2 = this[1];

  let a = point_2.x - point_1.x;
  let b = point_2.y - point_1.y;

  return Math.sqrt(a * a + b * b);
};

console.log(points1.dist());  // Работает на points1

points2.dist = points1.dist;  // Присваиваем метод dist из points1 в points2
console.log(points2.dist());  // Работает на points2
```

В этом примере метод `dist` был определен для массива `points1`, но затем мы присвоили его объекту `points2`. Поскольку структура объектов в обоих массивах одинаковая (каждый элемент массива содержит объекты с полями `x` и `y`), метод `dist` успешно работает и на `points2`.

### Однако важно учитывать:
- Если структура объектов в другом массиве или объекте отличается (например, в нем нет свойств `x` и `y`), то метод вызовет ошибку при попытке получить доступ к этим свойствам.
- Вы можете использовать `call` или `apply`, чтобы явно указать объект, на котором будет выполнен метод, что полезно, если вы хотите вызвать метод с другим контекстом.

Пример с использованием `call`:
```javascript
console.log(points1.dist.call(points2));  // Используем call для изменения контекста
```

### Итог:
Метод можно вызвать на другом объекте, но важно, чтобы структура этого объекта соответствовала тому, что ожидает метод (например, чтобы в объекте были необходимые свойства).

---

В JavaScript существует несколько способов объявления переменных: через `let`, `const` и `var`. Вот основные отличия между ними:

### 1. **`let`**:
- **Переменная может быть изменена**. После объявления переменной через `let` можно присваивать ей новое значение.
- **Область видимости** — блок (например, внутри цикла или функции). Это означает, что переменная, объявленная с `let`, доступна только в том блоке кода, в котором она была объявлена.
- **Повторное объявление в одной и той же области видимости невозможно**. Если вы попытаетесь объявить переменную с тем же именем в той же области видимости, получите ошибку.

```javascript
let x = 5;
x = 10;  // Это разрешено
```

### 2. **`const`**:
- **Переменная не может быть изменена** (константа). После того как переменной, объявленной с `const`, присвоено значение, его нельзя изменить.
- **Область видимости** — блок (как и с `let`).
- **Примечание**: `const` не означает, что значение самой переменной неизменно. Если переменная ссылается на объект или массив, содержимое объекта или массива может быть изменено.

```javascript
const y = 5;
y = 10;  // Ошибка, значение не может быть изменено

// Однако, если это объект или массив, то их содержимое можно изменить:
const arr = [1, 2, 3];
arr[0] = 10;  // Разрешено
```

### 3. **`var`**:
- **Переменная может быть изменена**, как и с `let`.
- **Область видимости** — функция (если объявлена внутри функции), или глобальная область видимости, если объявлена вне функции.
- **Подвержена поднятию** (hoisting). Это означает, что переменная будет доступна до того, как она будет фактически объявлена в коде (но с неопределенным значением, если попытаться использовать до объявления).
- **Повторное объявление в той же области видимости разрешено**. Это может привести к непредсказуемому поведению.

```javascript
var z = 5;
z = 10;  // Это разрешено

console.log(a); // undefined, из-за hoisting
var a = 3;
```

### Важные отличия между `let`, `const` и `var`:

| Характеристика                | `let`                             | `const`                         | `var`                           |
|-------------------------------|-----------------------------------|---------------------------------|---------------------------------|
| **Изменяемость**               | Можно изменить                    | Нельзя изменить                | Можно изменить                  |
| **Область видимости**          | Блок                              | Блок                            | Функция или глобальная          |
| **Повторное объявление**       | Нельзя в одной области видимости  | Нельзя в одной области видимости | Можно в одной области видимости |
| **Поднятие** (Hoisting)        | Да, но с undefined                | Да, но с ошибкой, если не инициализировано | Да, с undefined или ошибкой (зависит от использования) |

### Другие способы объявления переменных:
В JavaScript также есть другие методы, например, через **глобальную область видимости** (без ключевого слова) или через **`Object.defineProperty`** для динамического создания свойств объекта, но в современных практиках использование `let`, `const` и `var` являются основными способами объявления переменных.

### Рекомендации:
- Используйте **`const`**, если значение переменной не должно изменяться.
- Используйте **`let`**, если значение переменной будет изменяться.
- Используйте **`var`** только в случае работы с устаревшим кодом или если требуется поддержка старых браузеров (например, IE).

В современных JavaScript-проектах предпочтительнее использовать `let` и `const` для большей безопасности и предсказуемости кода.
