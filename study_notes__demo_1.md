# Study notes
---

В выражении `book.contents?.ch01?.sect1` используется **optional chaining** (опциональная цепочка) в JavaScript. Это позволяет безопасно обращаться к вложенным свойствам объекта, даже если какой-то из промежуточных объектов не существует (равен `null` или `undefined`).

Вот что происходит:

1. **`book`**: Это объект, у которого пытаются получить доступ к свойству `contents`.

2. **`contents?`**: Оператор `?.` проверяет, существует ли свойство `contents` у объекта `book`. Если `contents` существует (не `null` и не `undefined`), то выполняется попытка обращения к следующему свойству. Если `contents` не существует (равно `null` или `undefined`), то выражение сразу возвращает `undefined` и не вызывает ошибку.

3. **`ch01?`**: То же самое проверяется для свойства `ch01` внутри `contents`. Если `ch01` существует, то выполняется попытка обращения к следующему свойству.

4. **`sect1`**: Это свойство, к которому пытаются получить доступ в объекте `ch01`.

## Пример

- Если объект `book` выглядит так:

```javascript
let book = {
  contents: {
    ch01: {
      sect1: "Introduction"
    }
  }
};
```

- То выражение `book.contents?.ch01?.sect1` вернет `"Introduction"`.

Но если, например, `book.contents.ch01` не существует, то результатом будет `undefined` (без выбрасывания ошибки):

```javascript
let book = {
  contents: {}
};
console.log(book.contents?.ch01?.sect1);  // undefined
```

## Важные моменты

- **`?.`** предотвращает ошибку, если на каком-то уровне объекта что-то не существует.
- Это полезно, когда нужно обращаться к глубоким уровням вложенности, но не быть уверенным, что все объекты и свойства существуют.

---
В вашем примере:

```javascript
let empty = [];
```

- Это **объявление пустого массива**.
- В JavaScript **пустой массив** — это массив без элементов, то есть он **не содержит значений** на момент его создания.

Однако важно понимать, что **пустой массив** (`[]`) не имеет типа `undefined`. Он является массивом, а его элементы просто не определены на момент создания.

### Детали:

- **Массив** в JavaScript всегда имеет тип **`object`**, независимо от того, пуст ли он или содержит элементы.

  ```javascript
  console.log(typeof empty);  // "object"
  ```

- Если вы добавите элементы в этот массив, то они будут храниться внутри массива.

  ```javascript
  empty.push(10);
  console.log(empty);  // [10]
  ```

- **`undefined`** — это тип значения, которое может быть присвоено переменной, когда она еще не инициализирована, но не имеет отношения к типу самого массива.

  ```javascript
  let uninitialized;
  console.log(uninitialized);  // undefined
  ```

Таким образом:
- `let empty = [];` — это **объявление пустого массива** с типом **`object`**.
- **`undefined`** — это значение, которое может быть присвоено переменной, но не имеет отношения к самому массиву.

---

Да, точно! В JavaScript переменная `empty`, которая хранит пустой массив, имеет тип **`object`**.

Вот как это работает:

- **Переменная `empty`** — это ссылка на массив, и **сама переменная** имеет тип **`object`**, поскольку массивы в JavaScript являются подтипом объектов.

  ```javascript
  console.log(typeof empty);  // "object"
  ```

- **Содержимое массива** на момент его создания — это **пустой массив**, то есть в нем нет элементов. Пока в массиве нет данных, его длина равна нулю (`empty.length === 0`), но сам тип массива остаётся **`object`**.

  ```javascript
  console.log(empty.length);  // 0
  ```

- Массив может быть заполнен данными позже, и тогда тип содержимого будет зависеть от того, что именно вы в него добавляете.

  Например:

  ```javascript
  empty.push(10);
  console.log(empty);  // [10]
  console.log(typeof empty);  // "object"
  ```

Таким образом:
- **Переменная `empty`** имеет тип **`object`**, потому что она ссылается на массив (массивы — это объекты в JavaScript).
- **Содержимое массива** на момент его объявления — это пустой массив, и он может быть позже заполнен значениями.

---

В JavaScript используются разные типы данных для разных целей. Объясню, почему в вашем примере для одного массива использовались фигурные скобки `{}`, а для другого — квадратные скобки `[]`.

### 1. Объявление массива с объектами
```javascript
let coordinates = [
    { x: 10, y: 20 },
    { x: 30, y: 40 }
];
```

- Здесь `coordinates` — это **массив**, который хранит несколько **объектов**.
- Каждый объект в массиве описывает координаты с полями `x` и `y`.
- **Массивы** в JavaScript объявляются с использованием **квадратных скобок** `[]`, а **объекты** — с использованием **фигурных скобок** `{}`.
- Внутри массива вы видите объекты (каждый из которых описан с помощью фигурных скобок `{ x: 10, y: 20 }`), потому что это объекты, а не массивы.

### 2. Объявление объекта с массивами
```javascript
let data = {
    trial_1: [
        [1, 2],
        [3, 4]
    ],
    trial_2: [
        [5, 6],
        [7, 8]
    ]
};
```

- В этом примере `data` — это **объект**, в котором есть два свойства: `trial_1` и `trial_2`.
- Каждое из этих свойств содержит **массивы**, в которые вложены другие массивы.
- Вложенные массивы в объекте `data` объявляются с помощью **квадратных скобок** `[]`, поскольку это массивы, а не объекты.

### Почему разные скобки?
- **Квадратные скобки `[]`** используются для объявления **массивов** в JavaScript.
- **Фигурные скобки `{}`** используются для объявления **объектов** в JavaScript.

Итак:
- В первом случае `coordinates` — это **массив**, состоящий из **объектов**.
- Во втором случае `data` — это **объект**, содержащий **массивы**, которые в свою очередь содержат вложенные массивы.

---

Да, в вашем примере объекты в массиве `coordinates` являются **анонимными** объектами. Это означает, что эти объекты не имеют имени или идентификатора, с которым можно было бы напрямую ссылаться на них. Они просто описываются внутри массива как объекты с определенными свойствами (`x` и `y`).

Пример:
```javascript
let coordinates = [
    { x: 10, y: 20 },  // анонимный объект
    { x: 30, y: 40 }   // анонимный объект
];
```

- Эти объекты не присваиваются переменным с именами (например, `let point = { x: 10, y: 20 };`), их просто создают и помещают в массив. Такой подход называется **анонимными объектами**, потому что объекты создаются без явного указания имени для их ссылки.
- Вы можете обращаться к этим объектам через их индекс в массиве, например: `coordinates[0].x` или `coordinates[1].y`.

---

Да, именно так! В примере с объектом `data`:

```javascript
let data = {
    trial_1: [
        [1, 2],
        [3, 4]
    ],
    trial_2: [
        [5, 6],
        [7, 8]
    ]
};
```

- Объявляется **объект** `data`, у которого есть два **свойства**: `trial_1` и `trial_2`.
- Каждое из этих свойств (`trial_1` и `trial_2`) является **массивом**, который, в свою очередь, содержит **вложенные массивы**.

**Разбор:**

1. `data` — это объект.
2. `trial_1` и `trial_2` — это **свойства объекта**, которые хранят в себе **массивы**.
3. Каждый из этих массивов (содержимое `trial_1` и `trial_2`) состоит из **вложенных массивов** (например, `[1, 2]`, `[3, 4]`).

Таким образом:
- **`data`** — это объект, содержащий два свойства (`trial_1` и `trial_2`).
- Свойства `trial_1` и `trial_2` — это массивы.
- Эти массивы содержат **вложенные массивы**.
